/*!
\page quickstart TL;DR

To simplify [continous integration](https://origami.openpaper.work),
Makefiles in all [OpenPaper.work](https://openpaper.work) projects present similar targets.


# Compilation

## GNU/Linux and *BSD

```
sudo apt install cmake build-essential libsane-dev
make build_linux_c
```


## Microsoft Windows

Build is done on Linux using [MXE](http://mxe.cc/) which itself is based
on [MingW](http://www.mingw.org/).

As root, to install the required MXE packages:
```
echo "deb http://pkg.mxe.cc/repos/apt/debian jessie main" > \
    /etc/apt/sources.list.d/mxeapt.list
apt-key adv --keyserver keyserver.ubuntu.com \
    --recv-keys D43A795B73B16ABE9643FE1AFD8FFF16DB45C6AB
apt update
apt install \
    mxe-x86-64-w64-mingw32.static-glib \
    mxe-x86-64-unknown-linux-gnu-cmake \
    mxe-x86-64-w64-mingw32.static-gcc
```

As user:
```
make build_windows_c
```


## Both

```
make
```

# Installation

## For use in a C project


### Linux

```
sudo make install
```

or

```
sudo make install_linux_c
```

Will install the headers in /usr/local/include/libinsane.
Will install dynamic (libinsane.so) and static library (libinsane.a) in /usr/local/lib.


### Windows

In the folder 'build\_windows', you will find
[LibInsane compiled statically: libinsane.a](https://stackoverflow.com/questions/2096519/from-mingw-static-library-a-to-visual-studio-static-library-lib)
and dynamically.

Headers are in 'include/libinsane'.

In a Mingw/Msys2 environment, `make install` or `make install_windows_c` will work too.


# Usage


## In a C project

```
#include <libinsane/capi.h>
#include <libinsane/error.h>
#include <libinsane/safebet.h>
#include <libinsane/util.h>


#define CHECK_ERR(call) do { \
        err = call; \
        if (LIS_IS_ERROR(err)) { \
            fprintf( \
                stderr, "%s(L%d): ERROR: %X, %s\n", \
                __FILE__, __LINE__, \
                err, lis_strerror(err) \
            ); \
            goto end; \
        } \
    } while(0)


void lets_scan(void)
{
    enum lis_error err;
    struct lis_api *impl = NULL;
    struct lis_device_description **dev_infos;
    struct lis_item *device = NULL;
    struct lis_item **sources;
    struct lis_scan_parameters parameters;
    struct lis_scan_session *scan_session;
    char img_buffer[4096];
    size_t bufsize;

    CHECK_ERR(lis_safebet(&impl));
    CHECK_ERR(impl->get_devices(impl, &dev_infos));

    if (dev_infos[0] == NULL) {
        fprintf(stderr, "No scan device found\n");
        return;
    }

    // let's use the first scan device found, because it looks cool.
    printf("Will use %s %s (%s ; %s:%s)\n",
        dev_infos[0]->vendor, dev_infos[0]->model,
        dev_infos[0]->type,
        dev_infos[0]->dev_id,
        dev_infos[0]->api_name);
    CHECK_ERR(impl->dev_open(impl, dev_infos[0]->dev_id, &device));

    CHECK_ERR(device->get_children(device, &sources));

    // Normalizers ensure us that there is at least one source,
    // so let's use the first one because it looks cool too.
    printf("Will use source %s", sources[0]->name);

    // Setting resolution: This one may or may not work, depending on the scanner
    CHECK_ERR(lis_set_option(sources[0], "resolution", "300");
    // Normalizers ensure us that the mode option can take the value "Color"
    CHECK_ERR(lis_set_option(sources[0], "mode", "Color");
    CHECK_ERR(lis_maximize_scan_area(sources[0], device));

    CHECK_ERR(sources[0]->get_scan_parameters(sources[0], &parameters));
    printf("Scan will be: %dpx x %dpx (%zd bytes)\n",
        parameters.width, parameters.height, parameters.image_size);

    CHECK_ERR(sources[0]->scan_start(sources[0], &scan_session));

    do {
        bufsize = sizeof(img_buffer);
        err = scan_session->scan_read(scan_session, img_buffer, &bufsize);
        CHECK_ERR(err);

        switch(err) {
            case LIS_WARMING_UP:
                // old scanners need warming time. No data has been returned.
                assert(bufsize == 0);
                sleep(1);
                break;
            case LIS_OK:
                // do something with the chunk of the image/page that has just been read
                break;
            case LIS_CANCELLED:
                // user cancelled
                assert(bufsize == 0);
                goto end;
            case LIS_END_OF_PAGE:
                // one page scanned
                assert(bufsize == 0);
                break;
            case LIS_END_OF_FEED:
                // end of scan session
                assert(bufsize == 0);
                break;
            default:
                break;
        };
    } while(err != LIS_END_OF_FEED);

end:
    if (device != NULL) {
        device->dev_close(device);
    }
    if (impl != NULL) {
        impl->cleanup(impl);
    }
}
```

## In a project in any other programming language

Example: Python 3

\todo TODO

*/
